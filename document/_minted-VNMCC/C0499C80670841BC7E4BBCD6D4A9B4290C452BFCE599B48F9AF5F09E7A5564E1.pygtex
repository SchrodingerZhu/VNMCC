\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{o}{!}\PYG{p}{)} \PYG{o+ow}{::} \PYG{p}{(}\PYG{k+kt}{BitPack} \PYG{n}{a}\PYG{p}{,} \PYG{k+kt}{Enum} \PYG{n}{i}\PYG{p}{)} \PYG{o+ow}{=\PYGZgt{}} \PYG{n}{a} \PYG{o+ow}{\PYGZhy{}\PYGZgt{}} \PYG{n}{i} \PYG{o+ow}{\PYGZhy{}\PYGZgt{}} \PYG{k+kt}{Bit}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} \PYGZca{} BitVector is within the class of BitPack, so we can use (!) operator to fetch the value}

\PYG{n+nf}{vec} \PYG{o}{!} \PYG{l+m+mi}{0}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} \PYGZca{} fetch the lowest bit}

\PYG{n+nf}{slice} \PYG{o+ow}{::} \PYG{p}{(}\PYG{k+kt}{BitPack} \PYG{n}{a}\PYG{p}{,} \PYG{k+kt}{BitSize} \PYG{n}{a} \PYG{o}{\PYGZti{}} \PYG{p}{((}\PYG{n}{m} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{+} \PYG{n}{i}\PYG{p}{))}
    \PYG{o+ow}{=\PYGZgt{}} \PYG{k+kt}{SNat} \PYG{n}{m} \PYG{o+ow}{\PYGZhy{}\PYGZgt{}} \PYG{k+kt}{SNat} \PYG{n}{n} \PYG{o+ow}{\PYGZhy{}\PYGZgt{}} \PYG{n}{a} \PYG{o+ow}{\PYGZhy{}\PYGZgt{}} \PYG{k+kt}{BitVector} \PYG{p}{((}\PYG{n}{m} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{n}\PYG{p}{)}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} \PYGZca{} fetch a slice from the the bit vector}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} \PYGZca{} because the vector is defined as a dependent type}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} \PYGZca{} this interface is a bit terrifying, but it is handy to use}

\PYG{n+nf}{slice} \PYG{n}{d31} \PYG{n}{d20} \PYG{n}{vec}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} \PYGZca{} slice from index 31 to index 20}
\end{Verbatim}
